CREATE EXTENSION pg_track_optimizer;
-- Cleanup history
SELECT * FROM pg_track_optimizer_reset();
 pg_track_optimizer_reset
--------------------------

(1 row)

SET pg_track_optimizer.mode = 'forced';
/*
 * Test Subplan evaluation inside JOIN clause.
 * The Subplan should appear in the second part of an AND clause
 * with number of loops > 10.
 */
-- Create test tables
CREATE TABLE outer_table (
    id INTEGER,
    category INTEGER,
    val INTEGER
);
CREATE TABLE inner_table (
    id INTEGER,
    val INTEGER
);
CREATE TABLE reference_table (
    category INTEGER,
    threshold INTEGER
);
-- Insert data to ensure > 10 loops
-- outer_table: 20 rows across 5 categories
INSERT INTO outer_table
SELECT i, (i % 5) + 1, i * 10
FROM generate_series(1, 20) i;
-- inner_table: matching ids
INSERT INTO inner_table
SELECT i, i * 5
FROM generate_series(1, 20) i;
-- reference_table: thresholds for each category
INSERT INTO reference_table VALUES
(1, 50), (2, 100), (3, 150), (4, 200), (5, 250);
ANALYZE outer_table;
ANALYZE inner_table;
ANALYZE reference_table;
-- Force nested loop to ensure the SubPlan executes multiple times
SET enable_hashjoin = off;
SET enable_mergejoin = off;
/*
 * This query demonstrates:
 * 1. JOIN with two-part AND condition
 * 2. Second part contains a correlated subquery (becomes SubPlan)
 * 3. SubPlan evaluates for each outer row that passes first condition
 * 4. With 20 matching rows, SubPlan loops > 10 times
 */
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF, BUFFERS OFF)
SELECT o.id, o.category, o.val, i.val as inner_val
FROM outer_table o
JOIN inner_table i ON
    o.id = i.id AND  -- First part of AND: simple join condition
    o.val > (        -- Second part of AND: correlated subquery (SubPlan)
        SELECT threshold
        FROM reference_table r
        WHERE r.category = o.category
    );
                                          QUERY PLAN
----------------------------------------------------------------------------------------------
 Nested Loop (actual rows=16.00 loops=1)
   Join Filter: ((o.id = i.id) AND (o.val > (SubPlan 1)))
   Rows Removed by Join Filter: 304
   ->  Seq Scan on outer_table o (actual rows=20.00 loops=1)
   ->  Seq Scan on inner_table i (actual rows=20.00 loops=20)
   SubPlan 1
     ->  Seq Scan on reference_table r (actual rows=1.00 loops=20)
           Filter: (r.category = o.category)
           Rows Removed by Filter: 4
(9 rows)

-- Verify the SubPlan executed multiple times
-- The plan should show "SubPlan" with loops > 10
SELECT
  query,
  ROUND((avg_error -> 'mean')::numeric, 2) AS error,
  evaluated_nodes,
  plan_nodes,
  nexecs
FROM pg_track_optimizer()
WHERE query LIKE '%FROM outer_table%';
                               query                                | error | evaluated_nodes | plan_nodes | nexecs
--------------------------------------------------------------------+-------+-----------------+------------+--------
 EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF, BUFFERS OFF)+|  0.65 |               4 |          4 |      1
 SELECT o.id, o.category, o.val, i.val as inner_val               +|       |                 |            |
 FROM outer_table o                                                +|       |                 |            |
 JOIN inner_table i ON                                             +|       |                 |            |
     o.id = i.id AND                                               +|       |                 |            |
     o.val > (                                                     +|       |                 |            |
         SELECT threshold                                          +|       |                 |            |
         FROM reference_table r                                    +|       |                 |            |
         WHERE r.category = o.category                             +|       |                 |            |
     );                                                             |       |                 |            |
(1 row)

-- Also run the query to show actual results
SELECT o.id, o.category, o.val, i.val as inner_val
FROM outer_table o
JOIN inner_table i ON
    o.id = i.id AND
    o.val > (
        SELECT threshold
        FROM reference_table r
        WHERE r.category = o.category
    )
ORDER BY o.id;
 id | category | val | inner_val
----+----------+-----+-----------
  6 |        2 | 60  |        30
  7 |        3 | 70  |        35
  8 |        4 | 80  |        40
  9 |        5 | 90  |        45
 11 |        2 | 110 |        55
 12 |        3 | 120 |        60
 13 |        4 | 130 |        65
 14 |        5 | 140 |        70
 16 |        2 | 160 |        80
 17 |        3 | 170 |        85
 18 |        4 | 180 |        90
 19 |        5 | 190 |        95
  6 |        2 | 60  |        30
  7 |        3 | 70  |        35
  8 |        4 | 80  |        40
  9 |        5 | 90  |        45
(16 rows)

-- Cleanup
RESET enable_hashjoin;
RESET enable_mergejoin;
DROP EXTENSION pg_track_optimizer;
