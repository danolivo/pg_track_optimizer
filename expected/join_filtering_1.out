create or replace function portable_explain_analyze(query text)
returns table (out_line text) language plpgsql
as
$$
declare
  line text;
begin
  for line in
    execute 'EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF, BUFFERS OFF)' || query
  loop
    out_line := regexp_replace(line, '\d+kB', 'NNkB', 'g');
    out_line := regexp_replace(out_line, 'rows=(\d+)\.00', 'rows=\1', 'g');
    return next;
  end loop;
end;
$$;
CREATE EXTENSION pg_track_optimizer;
-- Cleanup history
SELECT * FROM pg_track_optimizer_reset();
 pg_track_optimizer_reset 
--------------------------
                        1
(1 row)

SET pg_track_optimizer.mode = 'forced';
/*
 * Test that filtered tuples from join nodes are counted correctly.
 * Join nodes can produce nfiltered1 values when they have join quals
 * that filter tuples (e.g., additional conditions beyond the hash/merge key).
 */
-- Create test tables
CREATE TABLE join_outer (
    id INTEGER,
    val INTEGER
);
CREATE TABLE join_inner (
    id INTEGER,
    val INTEGER
);
-- Insert data
INSERT INTO join_outer SELECT i, i % 10 FROM generate_series(1, 1000) i;
INSERT INTO join_inner SELECT i, i % 10 FROM generate_series(1, 100) i;
ANALYZE join_outer;
ANALYZE join_inner;
-- Force a nested loop join with a filter condition
-- The condition "join_outer.val = join_inner.val" will cause filtering
-- at the join level, producing nfiltered1 values
SET enable_hashjoin = off;
SET enable_mergejoin = off;
SET enable_material = off;
-- This query will produce a NestLoop with join filtering
-- The join condition includes both id match and val match,
-- where val match acts as a filter
SELECT portable_explain_analyze('
SELECT * FROM join_outer
JOIN join_inner ON join_outer.id = join_inner.id
WHERE join_outer.val + join_inner.val > 5;
');
                                   portable_explain_analyze                                   
----------------------------------------------------------------------------------------------
 Nested Loop (actual rows=70 loops=1)
   Join Filter: ((join_outer.id = join_inner.id) AND ((join_outer.val + join_inner.val) > 5))
   Rows Removed by Join Filter: 99930
   ->  Seq Scan on join_inner (actual rows=100 loops=1)
   ->  Seq Scan on join_outer (actual rows=1000 loops=100)
(5 rows)

-- Check that we tracked the query
-- The evaluated_nodes should include the join node with filtered tuples
SELECT
  query,
  ROUND((avg_error -> 'mean')::numeric,1) AS error,
  evaluated_nodes,
  plan_nodes,
  nexecs
FROM pg_track_optimizer()
WHERE query LIKE '%FROM join_outer%' AND
  query NOT LIKE '%portable_explain_analyze%' AND
  query NOT LIKE '%pg_track_optimizer%';
                               query                                | error | evaluated_nodes | plan_nodes | nexecs 
--------------------------------------------------------------------+-------+-----------------+------------+--------
 EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF, BUFFERS OFF)+|   0.3 |               3 |          3 |      1
 SELECT * FROM join_outer                                          +|       |                 |            | 
 JOIN join_inner ON join_outer.id = join_inner.id                  +|       |                 |            | 
 WHERE join_outer.val + join_inner.val > 5;                        +|       |                 |            | 
                                                                    |       |                 |            | 
(1 row)

-- Cleanup
RESET enable_hashjoin;
RESET enable_mergejoin;
RESET enable_material;
/*
 * Just for the demo:
 * XXX: How to detect such cases: we hash or sort the whole source but use only
 * minor part of it - no filters, just earlier stop or low usage of a hash table
 */
-- First pass: no signs of filtered tuples or estimation errors
SELECT portable_explain_analyze('SELECT * FROM join_inner JOIN join_outer USING (id);');
                   portable_explain_analyze                   
--------------------------------------------------------------
 Hash Join (actual rows=100 loops=1)
   Hash Cond: (join_outer.id = join_inner.id)
   ->  Seq Scan on join_outer (actual rows=1000 loops=1)
   ->  Hash (actual rows=100 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: NNkB
         ->  Seq Scan on join_inner (actual rows=100 loops=1)
(6 rows)

SELECT
  ROUND((avg_avg::numeric), 2) AS err,
  floor(jf_max) AS jf_max, floor(lf_max) AS lf_max,
  evaluated_nodes en, plan_nodes pn, nexecs nex
FROM pg_track_optimizer
WHERE query LIKE '%join_inner JOIN join_outer USING (id)%' AND
  query NOT LIKE '%portable_explain_analyze%' AND
  query NOT LIKE '%pg_track_optimizer%';
 err  | jf_max | lf_max | en | pn | nex 
------+--------+--------+----+----+-----
 0.00 |      0 |      0 |  4 |  4 |   1
(1 row)

SELECT portable_explain_analyze('SELECT * FROM join_inner JOIN join_outer USING (id) LIMIT 1;');
                      portable_explain_analyze                      
--------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Hash Join (actual rows=1 loops=1)
         Hash Cond: (join_outer.id = join_inner.id)
         ->  Seq Scan on join_outer (actual rows=1 loops=1)
         ->  Hash (actual rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: NNkB
               ->  Seq Scan on join_inner (actual rows=100 loops=1)
(7 rows)

SELECT
  ROUND((avg_avg::numeric), 2) AS err,
  floor(jf_max) AS jf_max, floor(lf_max) AS lf_max,
  evaluated_nodes en, plan_nodes pn, nexecs nex
FROM pg_track_optimizer
WHERE query LIKE '%join_inner JOIN join_outer USING (id)%' AND
  query NOT LIKE '%portable_explain_analyze%' AND
  query NOT LIKE '%pg_track_optimizer%';
 err  | jf_max | lf_max | en | pn | nex 
------+--------+--------+----+----+-----
 0.00 |      0 |      0 |  4 |  4 |   1
 2.30 |      0 |      0 |  5 |  5 |   1
(2 rows)

CREATE INDEX join_outer_id_idx ON join_outer (id);
-- Second pass: only MergeJoin runtime optimisation detects an estimation error
SELECT portable_explain_analyze('SELECT * FROM join_inner JOIN join_outer USING (id);');
                             portable_explain_analyze                             
----------------------------------------------------------------------------------
 Merge Join (actual rows=100 loops=1)
   Merge Cond: (join_outer.id = join_inner.id)
   ->  Index Scan using join_outer_id_idx on join_outer (actual rows=101 loops=1)
   ->  Sort (actual rows=100 loops=1)
         Sort Key: join_inner.id
         Sort Method: quicksort  Memory: NNkB
         ->  Seq Scan on join_inner (actual rows=100 loops=1)
(7 rows)

SELECT
  ROUND((avg_avg::numeric), 2) AS err,
  floor(jf_max) AS jf_max, floor(lf_max) AS lf_max,
  evaluated_nodes en,
  plan_nodes pn,
  nexecs nex
FROM pg_track_optimizer
WHERE query LIKE '%join_inner JOIN join_outer USING (id)%' AND
  query NOT LIKE '%portable_explain_analyze%' AND
  query NOT LIKE '%pg_track_optimizer%';
 err  | jf_max | lf_max | en | pn | nex 
------+--------+--------+----+----+-----
 0.29 |      0 |      0 |  4 |  4 |   2
 2.30 |      0 |      0 |  5 |  5 |   1
(2 rows)

DROP INDEX join_outer_id_idx;
TRUNCATE join_inner;
INSERT INTO join_inner SELECT i, i % 10 FROM generate_series(-50, 50) i;
VACUUM ANALYZE join_inner;
SET enable_mergejoin = off;
SET enable_material = off;
SELECT portable_explain_analyze('SELECT * FROM join_inner JOIN join_outer USING (id);');
                   portable_explain_analyze                   
--------------------------------------------------------------
 Hash Join (actual rows=50 loops=1)
   Hash Cond: (join_outer.id = join_inner.id)
   ->  Seq Scan on join_outer (actual rows=1000 loops=1)
   ->  Hash (actual rows=101 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: NNkB
         ->  Seq Scan on join_inner (actual rows=101 loops=1)
(6 rows)

SET enable_hashjoin = off;
SELECT portable_explain_analyze('SELECT * FROM join_inner JOIN join_outer USING (id);');
                 portable_explain_analyze                  
-----------------------------------------------------------
 Nested Loop (actual rows=50 loops=1)
   Join Filter: (join_inner.id = join_outer.id)
   Rows Removed by Join Filter: 100950
   ->  Seq Scan on join_inner (actual rows=101 loops=1)
   ->  Seq Scan on join_outer (actual rows=1000 loops=101)
(5 rows)

RESET enable_hashjoin;
RESET enable_mergejoin;
RESET enable_material;
DROP FUNCTION portable_explain_analyze;
DROP TABLE join_inner,join_outer;
SELECT * FROM pg_track_optimizer_reset();
 pg_track_optimizer_reset 
--------------------------
                        9
(1 row)

DROP EXTENSION pg_track_optimizer;
