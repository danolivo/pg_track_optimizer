-- Test rstats base type
CREATE EXTENSION pg_track_optimizer;
\set VERBOSITY terse
-- Test 1: Basic rstats creation and initialization
SELECT 42.5::rstats;
                     rstats                     
------------------------------------------------
 (count:1,mean:42.5,min:42.5,max:42.5,stddev:0)
(1 row)

SELECT (42.1::double precision)::rstats;
                     rstats                     
------------------------------------------------
 (count:1,mean:42.1,min:42.1,max:42.1,stddev:0)
(1 row)

SELECT (NULL::double precision)::rstats;
 rstats 
--------
 
(1 row)

SELECT rstats(); -- Check empty state
                rstats                 
---------------------------------------
 (count:0,mean:0,min:0,max:0,stddev:0)
(1 row)

SELECT NULL::rstats -> 'mean';
 ?column? 
----------
         
(1 row)

SELECT rstats('abc'); -- ERROR, rstats_in have a different format
ERROR:  invalid input syntax for type rstats: "abc" at character 15
SELECT rstats(0), rstats(-1), rstats(36.6);
                rstats                 |                  rstats                  |                     rstats                     
---------------------------------------+------------------------------------------+------------------------------------------------
 (count:1,mean:0,min:0,max:0,stddev:0) | (count:1,mean:-1,min:-1,max:-1,stddev:0) | (count:1,mean:36.6,min:36.6,max:36.6,stddev:0)
(1 row)

SELECT rstats('12'::int2);
                  rstats                  
------------------------------------------
 (count:1,mean:12,min:12,max:12,stddev:0)
(1 row)

SELECT q.s, q.s + 1.0, q.s + 2.0, q.s + NULL
  FROM (VALUES (1.0::rstats)) AS q(s);
                   s                   |               ?column?                |                        ?column?                         | ?column? 
---------------------------------------+---------------------------------------+---------------------------------------------------------+----------
 (count:1,mean:1,min:1,max:1,stddev:0) | (count:2,mean:1,min:1,max:1,stddev:0) | (count:2,mean:1.5,min:1,max:2,stddev:0.707106781186548) | 
(1 row)

SELECT q.s, q.s + 1.0, q.s + NULL FROM (VALUES (NULL::rstats)) AS q(s);
 s | ?column? | ?column? 
---+----------+----------
   |          | 
(1 row)

SELECT q.s, q.s + 1.0 FROM
  (VALUES (('+Infinity'::double precision)::rstats)) AS q(s);
                             s                              |                     ?column?                     
------------------------------------------------------------+--------------------------------------------------
 (count:1,mean:Infinity,min:Infinity,max:Infinity,stddev:0) | (count:2,mean:NaN,min:1,max:Infinity,stddev:NaN)
(1 row)

-- Test 2: Create table with rstats column
CREATE TABLE sensor_data (
  sensor_id integer,
  measurements rstats
);
-- Test 3: Insert initial rstats values
INSERT INTO sensor_data VALUES
  (1, 10.0::rstats), (2, 20.0::rstats), (3, 15.5::rstats);
-- Test 4: Add values to rstats using the + operator
UPDATE sensor_data SET measurements = measurements + 20.0 WHERE sensor_id = 1;
UPDATE sensor_data SET measurements = measurements + 25.0 WHERE sensor_id = 2;
UPDATE sensor_data SET measurements = measurements + 18.5 WHERE sensor_id = 3;
-- Add more values to build up rstats
UPDATE sensor_data SET measurements = measurements + 30.0 WHERE sensor_id = 1;
UPDATE sensor_data SET measurements = measurements + 22.0 WHERE sensor_id = 2;
-- Test 5: Query rstats properties
-- NOTE: don't forget to stabilise output rounding double variables
SELECT
    sensor_id,
    measurements -> 'count' as count,
    ROUND((measurements -> 'mean')::numeric, 2) as mean,
    measurements -> 'min' as min,
    measurements -> 'max' as max,
    ROUND((measurements -> 'stddev')::numeric, 2) as stddev2,
    ROUND((measurements -> 'stddev')::numeric, 2) as stddev
FROM sensor_data
ORDER BY sensor_id;
 sensor_id | count | mean  | min  | max  | stddev2 | stddev 
-----------+-------+-------+------+------+---------+--------
         1 |     3 | 20.00 |   10 |   30 |   10.00 |  10.00
         2 |     3 | 22.33 |   20 |   25 |    2.52 |   2.52
         3 |     2 | 17.00 | 15.5 | 18.5 |    2.12 |   2.12
(3 rows)

-- Test 6: Equality comparison
-- Create two identical rstats
SELECT (10.0::rstats + 20.0 + 30.0) = (10.0::rstats + 20.0 + 30.0) as equal_stats;
 equal_stats 
-------------
 t
(1 row)

-- Create two different rstats
SELECT (10.0::rstats + 20.0) = (15.0::rstats + 15.0) as different_stats;
 different_stats 
-----------------
 f
(1 row)

-- Test 7: Compare rstats in table
INSERT INTO sensor_data VALUES (4, 10.0::rstats + 11.0 + 12.0);
INSERT INTO sensor_data VALUES (5, 10.0::rstats + 11.0 + 12.0);
SELECT s1.sensor_id as sensor1, s2.sensor_id as sensor2,
       s1.measurements = s2.measurements as are_equal
FROM sensor_data s1, sensor_data s2
WHERE s1.sensor_id = 4 AND s2.sensor_id = 5;
 sensor1 | sensor2 | are_equal 
---------+---------+-----------
       4 |       5 | t
(1 row)

-- Test 8: Text representation
SELECT sensor_id, measurements::text
FROM sensor_data
WHERE sensor_id <= 1
ORDER BY sensor_id;
 sensor_id |               measurements                
-----------+-------------------------------------------
         1 | (count:3,mean:20,min:10,max:30,stddev:10)
(1 row)

-- Test 10: Field accessor using -> operator
SELECT
    sensor_id,
    measurements -> 'count' as count,
    ROUND((measurements -> 'mean')::numeric, 2) as mean,
    measurements -> 'min' as min,
    measurements -> 'max' as max,
    ROUND((measurements -> 'stddev')::numeric, 2) as stddev2,
    ROUND((measurements -> 'stddev')::numeric, 2) as stddev
FROM sensor_data
WHERE sensor_id <= 3
ORDER BY sensor_id;
 sensor_id | count | mean  | min  | max  | stddev2 | stddev 
-----------+-------+-------+------+------+---------+--------
         1 |     3 | 20.00 |   10 |   30 |   10.00 |  10.00
         2 |     3 | 22.33 |   20 |   25 |    2.52 |   2.52
         3 |     2 | 17.00 | 15.5 | 18.5 |    2.12 |   2.12
(3 rows)

-- Test 11: Using -> operator in WHERE clause
SELECT sensor_id, ROUND((measurements -> 'mean')::numeric, 2) as mean
FROM sensor_data
WHERE (measurements -> 'mean') > 15
ORDER BY sensor_id;
 sensor_id | mean  
-----------+-------
         1 | 20.00
         2 | 22.33
         3 | 17.00
(3 rows)

-- Test 12: Invalid field name (should error)
-- SELECT measurements -> 'invalid_field' FROM sensor_data LIMIT 1;
-- Test 13: Sentinel Value Validation (from rstats.md Testing Recommendations)
-- Test 13.1: Valid empty state - should succeed
SELECT '(count:0,mean:0,min:0,max:0,stddev:0)'::rstats;
                rstats                 
---------------------------------------
 (count:0,mean:0,min:0,max:0,stddev:0)
(1 row)

-- Test 13.2: Reject corrupt empty state - count=0 with non-zero mean
SELECT '(count:0,mean:1,min:0,max:0,stddev:0)'::rstats;
ERROR:  RStats with count=0 must have all zero fields at character 8
-- Test 13.3: Reject corrupt empty state - count=0 with non-zero min
SELECT '(count:0,mean:0,min:-1,max:0,stddev:0)'::rstats;
ERROR:  RStats with count=0 must have all zero fields at character 8
-- Test 13.4: Reject corrupt empty state - count=0 with non-zero max
SELECT '(count:0,mean:0,min:0,max:5,stddev:0)'::rstats;
ERROR:  RStats with count=0 must have all zero fields at character 8
-- Test 13.5: Reject corrupt empty state - count=0 with non-zero stddev
SELECT '(count:0,mean:0,min:0,max:0,stddev:1.5)'::rstats;
ERROR:  RStats with count=0 must have all zero fields at character 8
-- Test 13.6: Binary round-trip
SELECT rstats()::bytea::rstats;
                rstats                 
---------------------------------------
 (count:0,mean:0,min:0,max:0,stddev:0)
(1 row)

-- Test 13.7: Init with zero vs. empty - should have different counts
SELECT (rstats(0.0) -> 'count')::int AS init_zero_count,
       (rstats() -> 'count')::int AS empty_count;
 init_zero_count | empty_count 
-----------------+-------------
               1 |           0
(1 row)

-- Test 13.8: Empty state equality - canonical representation
SELECT rstats() = '(count:0,mean:0,min:0,max:0,stddev:0)'::rstats AS empty_equals;
 empty_equals 
--------------
 t
(1 row)

-- Test 13.9: Empty state field access - all should be zero
SELECT
    (rstats() -> 'count')::int as count,
    (rstats() -> 'mean')::numeric as mean,
    (rstats() -> 'min')::numeric as min,
    (rstats() -> 'max')::numeric as max,
    (rstats() -> 'stddev')::numeric as stddev;
 count | mean | min | max | stddev 
-------+------+-----+-----+--------
     0 |    0 |   0 |   0 |      0
(1 row)

-- Test 14: Indexing on RStats fields
-- Demonstrates that expression indexes work on extracted RStats fields
-- Test 14.1: Single-column index on mean for range queries
CREATE INDEX sd_idx_mean ON sensor_data ((measurements -> 'mean'));
SET enable_seqscan = 'off';
-- Should use index scan for range query
EXPLAIN (COSTS OFF) SELECT sensor_id, measurements -> 'mean' as mean
FROM sensor_data
WHERE measurements -> 'mean' > 15
ORDER BY measurements -> 'mean';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Index Scan using sd_idx_mean on sensor_data
   Index Cond: ((measurements -> 'mean'::text) > '15'::double precision)
(2 rows)

RESET enable_seqscan;
DROP INDEX sd_idx_mean;
-- Test 14.2: Multi-column index for compound queries
-- Index column order: (count, mean) allows filtering by count and sorting by mean
CREATE INDEX sd_idx_compound
  ON sensor_data ((measurements -> 'count'), (measurements -> 'mean'));
SET enable_seqscan = 'off';
-- Should use index for WHERE clause (but may still need Sort for ORDER BY)
EXPLAIN (COSTS OFF) SELECT sensor_id FROM sensor_data
WHERE measurements -> 'count' > 0
ORDER BY measurements -> 'mean';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Sort
   Sort Key: ((measurements -> 'mean'::text))
   ->  Index Scan using sd_idx_compound on sensor_data
         Index Cond: ((measurements -> 'count'::text) > '0'::double precision)
(4 rows)

RESET enable_seqscan;
DROP INDEX sd_idx_compound;
-- Test 14.3: Index for statistics-based filtering
-- Useful for finding queries with high stddev or outliers
CREATE INDEX sd_idx_stddev ON sensor_data ((measurements -> 'stddev'));
SET enable_seqscan = 'off';
-- Find measurements with high stddev
EXPLAIN (COSTS OFF) SELECT sensor_id
FROM sensor_data
WHERE measurements -> 'stddev' > 5;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Index Scan using sd_idx_stddev on sensor_data
   Index Cond: ((measurements -> 'stddev'::text) > '5'::double precision)
(2 rows)

RESET enable_seqscan;
DROP INDEX sd_idx_stddev;
-- Next step: can we forbid such an update somehow? We only should allow
-- explicit initialization and INSERT of a new value.
CREATE TEMP TABLE tmp AS (SELECT * FROM sensor_data);
UPDATE sensor_data SET measurements = rstats();
SELECT * FROM sensor_data;
 sensor_id |             measurements              
-----------+---------------------------------------
         3 | (count:0,mean:0,min:0,max:0,stddev:0)
         1 | (count:0,mean:0,min:0,max:0,stddev:0)
         2 | (count:0,mean:0,min:0,max:0,stddev:0)
         4 | (count:0,mean:0,min:0,max:0,stddev:0)
         5 | (count:0,mean:0,min:0,max:0,stddev:0)
(5 rows)

UPDATE sensor_data s SET measurements = v.measurements FROM tmp v
WHERE v.sensor_id = s.sensor_id;
SELECT * FROM sensor_data;
 sensor_id |                             measurements                              
-----------+-----------------------------------------------------------------------
         3 | (count:2,mean:17,min:15.5,max:18.5,stddev:2.12132034355964)
         1 | (count:3,mean:20,min:10,max:30,stddev:10)
         2 | (count:3,mean:22.3333333333333,min:20,max:25,stddev:2.51661147842358)
         4 | (count:3,mean:11,min:10,max:12,stddev:1)
         5 | (count:3,mean:11,min:10,max:12,stddev:1)
(5 rows)

-- Test 15: rstats_agg aggregate function
CREATE TABLE agg_test (grp int, val double precision);
INSERT INTO agg_test VALUES (1, 10), (1, 20), (1, 30);
INSERT INTO agg_test VALUES (2, 5), (2, 15);
INSERT INTO agg_test VALUES (3, 100);
-- Basic aggregation by group
SELECT grp, rstats_agg(val) FROM agg_test GROUP BY grp ORDER BY grp;
 grp |                       rstats_agg                       
-----+--------------------------------------------------------
   1 | (count:3,mean:20,min:10,max:30,stddev:10)
   2 | (count:2,mean:10,min:5,max:15,stddev:7.07106781186548)
   3 | (count:1,mean:100,min:100,max:100,stddev:0)
(3 rows)

-- Verify statistics are correct
SELECT grp,
       (rstats_agg(val) -> 'count')::int as count,
       (rstats_agg(val) -> 'mean')::numeric as mean,
       (rstats_agg(val) -> 'min')::numeric as min,
       (rstats_agg(val) -> 'max')::numeric as max
FROM agg_test GROUP BY grp ORDER BY grp;
 grp | count | mean | min | max 
-----+-------+------+-----+-----
   1 |     3 |   20 |  10 |  30
   2 |     2 |   10 |   5 |  15
   3 |     1 |  100 | 100 | 100
(3 rows)

-- Test with NULL values (should be skipped)
INSERT INTO agg_test VALUES (4, NULL), (4, 50), (4, NULL), (4, 100);
SELECT grp, rstats_agg(val) FROM agg_test WHERE grp = 4 GROUP BY grp;
 grp |                        rstats_agg                        
-----+----------------------------------------------------------
   4 | (count:2,mean:75,min:50,max:100,stddev:35.3553390593274)
(1 row)

-- Test aggregation without GROUP BY
SELECT rstats_agg(val) FROM agg_test WHERE grp <= 2;
                       rstats_agg                       
--------------------------------------------------------
 (count:5,mean:16,min:5,max:30,stddev:9.61769203083567)
(1 row)

DROP TABLE agg_test;
-- Clean up
DROP TABLE sensor_data,tmp;
SELECT * FROM pg_track_optimizer_reset();
 pg_track_optimizer_reset 
--------------------------
                       37
(1 row)

DROP EXTENSION pg_track_optimizer;
